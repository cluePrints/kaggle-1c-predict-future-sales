# AUTOGENERATED! DO NOT EDIT! File to edit: 020_trivial_predict.ipynb (unless otherwise specified).

__all__ = ['read_train', 'forecast_to_submission', 'forecast_last_average']

# Cell
import pandas as pd
import numpy as np

# Cell
def read_train(n_sample_items=None, sample_random_state=None):
    train = pd.read_csv('raw/sales_train.csv')
    if (n_sample_items):
        r = np.random.RandomState(sample_random_state)
        item_ids = set(r.choice(train['item_id'].unique(), size=n_sample_items, replace=False))
        train = train.loc[train['item_id'].isin(item_ids)]
    train['date'] = pd.to_datetime(train['date'])
    return train

# Cell
def forecast_to_submission(forecast):
    test = pd.read_csv('raw/test.csv')
    submission = test.merge(forecast, on=['item_id', 'shop_id'], how='left')
    assert len(test) == len(submission), (f"Generated submission length({len(submission)})" +
     f" doesn't match to expected submission length ({len(test)})")
    submission.fillna(0, inplace=True)
    submission.drop(['shop_id', 'item_id'], axis=1, inplace=True)
    return submission

# Cell
def forecast_last_average(trn, forecast_month_length, train_interval_len, target_forecast_start):
    target_forecast_start = pd.to_datetime(target_forecast_start)
    tmp = trn.copy()
    tmp['days_before_target'] = (target_forecast_start - tmp['date']).dt.days
    tmp = tmp.query('days_before_target > 0 and days_before_target < @train_interval_len')

    forecast = (tmp
        .groupby(['item_id', 'shop_id'],
                as_index=False)
        .agg({'item_cnt_day': ['sum', 'count'],
              'date': ['min', 'max']})
    )
    forecast['sale_days'] = (forecast['date']['max']-forecast['date']['min']).dt.days + 1
    forecast['avg_daily_sale_items'] = forecast['item_cnt_day']['sum'] / train_interval_len

    forecast = pd.DataFrame({
        'item_id': forecast['item_id'],
        'shop_id': forecast['shop_id'],
        'item_cnt_month': forecast['avg_daily_sale_items']*forecast_month_length
    })
    return forecast